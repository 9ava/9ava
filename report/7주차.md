# 7주차: 세션과 쿠키 기반 인증 흐름 이해

## 1. 상태 유지 전략 (Session vs Cookie)

HTTP 프로토콜은 **비상태(Stateless)** 프로토콜입니다. 즉, 서버는 클라이언트의 이전 요청 상태를 기억하지 못합니다. 따라서 사용자가 로그인을 하더라도 다음 요청에서는 다시 로그인을 해야 하는 문제가 발생합니다. 이러한 문제를 해결하고 사용자의 로그인 상태를 유지하기 위해 **상태 유지(Stateful)** 전략이 필요하며, 대표적으로 쿠키와 세션을 사용합니다.

### 1.1. 쿠키 (Cookie)

- **개념**: 클라이언트(브라우저)에 저장되는 작은 데이터 조각입니다. 서버는 클라이언트에게 쿠키를 보내고, 클라이언트는 이후의 모든 요청에 해당 쿠키를 포함하여 서버에 전송합니다.
- **동작 방식**:
    1. 클라이언트가 서버에 요청을 보냅니다.
    2. 서버는 `Set-Cookie` 헤더를 통해 클라이언트에게 쿠키를 전송합니다.
    3. 클라이언트는 쿠키를 저장하고, 다음 요청부터 `Cookie` 헤더에 쿠키를 담아 서버로 전송합니다.
- **장점**:
    - 서버의 부하를 줄일 수 있습니다. (상태 정보를 클라이언트에 저장)
- **단점**:
    - 보안에 취약합니다. (쿠키 정보가 그대로 노출되거나 변조될 위험)
    - 저장할 수 있는 데이터 양에 제한이 있습니다.

### 1.2. 세션 (Session)

- **개념**: 서버 측에 사용자 정보를 저장하고, 클라이언트와는 고유한 **세션 ID**를 통해 통신하는 방식입니다.
- **동작 방식**:
    1. 클라이언트가 로그인을 시도합니다.
    2. 서버는 사용자 정보를 확인하고, 성공 시 고유한 세션 ID를 생성하여 서버의 세션 저장소에 저장합니다.
    3. 서버는 이 세션 ID를 쿠키에 담아 클라이언트에게 전송합니다.
    4. 클라이언트는 이후 요청 시 세션 ID가 담긴 쿠키를 서버에 전송합니다.
    5. 서버는 세션 ID를 통해 세션 저장소에서 사용자 정보를 찾아 인증을 유지합니다.
- **장점**:
    - 보안성이 쿠키보다 높습니다. (중요 정보는 서버에 저장)
    - 저장할 수 있는 데이터 양에 제한이 없습니다.
- **단점**:
    - 서버의 메모리나 저장 공간을 차지하여 부하가 발생할 수 있습니다.
    - 여러 서버 환경(로드 밸런싱)에서는 세션 공유를 위한 추가적인 기술이 필요합니다. (e.g., Sticky Session, Session Clustering, Session Storage)

### 1.3. 쿠키 vs 세션 비교

| 구분 | 쿠키 (Cookie) | 세션 (Session) |
| --- | --- | --- |
| **저장 위치** | 클라이언트 (브라우저) | 서버 |
| **보안** | 상대적으로 낮음 | 상대적으로 높음 |
| **데이터 크기** | 작음 (약 4KB) | 제한 없음 |
| **서버 부하** | 낮음 | 높음 |
| **라이프 사이클** | 브라우저 종료 시 만료되거나, 설정된 만료 시간까지 유지 | 브라우저 종료 시 만료되거나, 서버에서 설정한 타임아웃까지 유지 |

## 2. 로그인 구조 적용 예시 (세션 기반)

세션 기반 인증은 가장 일반적인 로그인 방식입니다. 다음은 일반적인 웹 애플리케이션의 로그인 처리 흐름입니다.

### 2.1. 로그인 인증 흐름

1.  **로그인 시도**: 사용자가 아이디와 비밀번호를 입력하고 로그인 버튼을 클릭합니다.
2.  **서버 인증**:
    -   서버는 사용자가 입력한 아이디와 비밀번호를 받습니다.
    -   데이터베이스에 저장된 사용자 정보와 일치하는지 확인합니다.
3.  **세션 생성 및 쿠키 발급**:
    -   인증에 성공하면, 서버는 해당 사용자를 위한 **세션(Session)**을 생성하고, 고유한 **세션 ID**를 발급합니다.
    -   생성된 세션에는 사용자 정보(예: 회원 ID, 닉네임, 권한 등)를 저장합니다.
    -   서버는 발급한 세션 ID를 `Set-Cookie` 헤더에 담아 클라이언트(브라우저)에게 응답으로 보냅니다.
4.  **쿠키 저장**:
    -   클라이언트는 서버로부터 받은 세션 ID를 쿠키에 저장합니다.
5.  **인증 상태 확인**:
    -   이후 클라이언트는 서버에 요청을 보낼 때마다 저장된 세션 ID 쿠키를 함께 전송합니다.
    -   서버는 요청에 포함된 세션 ID를 확인하고, 서버의 세션 저장소에 해당 ID가 유효한지 검증합니다.
    -   세션 ID가 유효하면, 사용자는 **인증된(Authenticated)** 상태로 간주되어 요청한 페이지나 기능에 접근할 수 있습니다.
6.  **로그아웃**:
    -   사용자가 로그아웃을 요청하면, 서버는 해당 세션을 무효화하고 저장소에서 삭제합니다.
    -   클라이언트에 저장된 세션 쿠키도 만료시켜 삭제하도록 응답을 보냅니다.

### 2.2. 보안 고려사항

-   **세션 하이재킹 (Session Hijacking)**: 공격자가 다른 사용자의 세션 ID를 탈취하여 해당 사용자로 위장하는 공격입니다.
    -   **대응**: HTTPS를 사용하여 통신을 암호화하고, 쿠키에 `Secure` 및 `HttpOnly` 속성을 설정하여 스크립트 접근을 막아야 합니다.
-   **세션 고정 (Session Fixation)**: 공격자가 미리 알고 있는 세션 ID를 사용자에게 사용하도록 강요하는 공격입니다.
    -   **대응**: 로그인 성공 시, 이전 세션을 파기하고 새로운 세션 ID를 발급해야 합니다.
-   **CSRF (Cross-Site Request Forgery)**: 사용자가 자신의 의지와 무관하게 공격자가 의도한 행위를 특정 웹사이트에 요청하게 하는 공격입니다.
    -   **대응**: `SameSite` 쿠키 속성을 설정하고, CSRF 토큰을 사용하여 방어할 수 있습니다.
